---
sticky: ""
title: 一种经典的组合数转化
date: 2022-11-20 13:54:24
updated: 2022-11-20 13:58:07
tags:
  - 组合
categories:
  - 数学
comments: true
---
## 1

> 有两个长度为 $n$ 的序列，每个数均在 $0,1$ 中随机取，求两个序列的和相等的方案数。

可以枚举和是多少，计算两个序列和都为这个数时的方案数：
$$
ANS=\sum_{i=0}^n\binom{n}{i}^2
$$
有一种求法是用卷积+生成函数化简，但太不优雅了。

考虑对于任意一种合法的序列，令两序列的和都为 $x$

即每个序列都有 $x$ 个 $1$ 和 $n-x$ 个 $0$。

发现这不是很好求，但如果把第二个序列反一下（$0$ 变 $1$，$1$ 变 $0$），会得到一个新的序列。

容易发现一个和为 $x$ 的原序列可以转化成唯一一个和为 $n-x$ 的新序列，一个新序列也可以唯一得到一个原序列。

问题就转化成了 $2$ 个序列，一个序列的和为 $x$，另一个序列的和为 $n-x$ 的方案数，$x\in[0,n]$。

发现 $2$ 个序列的的总数为 $n$，即对于任意一个长度为 $2n$，和为 $n$ 的序列分成左右两份后一定是满足条件的，可以直接用组合数求。

可得
$$
ANS=\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}
$$

## 2

> 有两个序列，一个序列长度为 $n$ 的序列，一个序列长度为 $m$，每个数均在 $0,1$ 中随机取，求两个序列的和相等的方案数。

假设 $n<m$，可以列出最朴素的式子
$$
ANS=\sum_{i=0}^n\binom{n}{i}\binom{m}{i}
$$
和刚才一样考虑，若第一个序列有 $x$ 个 $1$ 和 $n-x$ 个 $0$，则第二个序列必须有 $x$ 个 $1$ 和 $m-x$ 个 $0$。

考虑对第二个序列进行反转，则第二个序列对应的新序列有 $m-x$ 个 $1$ 和 $x$ 个 $0$。

问题再一次转化成一个长度为 $n$ 的序列有 $x$ 个 $1$，一个长度为 $m$ 的序列有 $m-x$ 个 $1$ 的方案数。

两个总共 $1$ 的个数一直是 $m$，对于任意一个长度为 $n+m$ 并且有 $m$ 个 $1$ 的序列分成左右两份即可得到原序列。
$$
ANS=\sum_{i=0}^n\binom{n}{i}\binom{m}{i}=\binom{n+m}{n}=\binom{n+m}{m}
$$

## 3

> 有两个序列，一个序列长度为 $n$ 的序列，一个序列长度为 $m$，每个数均在 $[0,k]$ 中随机取一个整数，求两个序列的和相等的方案数。

令函数 $f(n,s)$ 表示一个长度为 $n$ 的序列，每个数取值为 $[0,k]$ 并且和为 $s$ 的方案数。

考虑用组合数计算不考虑每个数取值上限的方案数，再进行容斥，枚举有几个数超出。
$$
f(n,s)=\sum_{i=0}^{\left\lfloor\frac{s}{k}\right\rfloor}(-1)^{i}\binom{n}{i}\binom{s-ik+n-1}{n-1}
$$
设 $n<m$，枚举每个序列的和计算总方案数
$$
ANS=\sum_{i=0}^{nk}f(n,i)f(m,i)
$$
依然可以用特别恶心的卷积+生成函数。

考虑两个序列和为 $x$，把第二个序列中的每个数 $b_i$ 变成 $k-b_i$ 会得到唯一一个新序列。

现在的第二个序列的新序列每个数还是位于 $[0,k]$，总和变成了 $mk-x$。

把两个序列并在一起的序列满足总和为 $mk$，长度为 $n+m$

对于任意一个总和为 $mk$ 的序列都可以分成左右两份，右边长度为 $m$ 的一份变化成唯一对应的原序列即可满足条件。

即为
$$
ANS=\sum_{i=0}^{nk}f(n,i)f(m,i)=f(n+m,mk)=f(n+m,nk)
$$
